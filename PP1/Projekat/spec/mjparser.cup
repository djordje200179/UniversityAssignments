package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
	private boolean errorDetected = false;
	
	public boolean hasError() {
		return errorDetected;
	}
     
    public void report_fatal_error(String message, Object info) throws Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error: ", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_fatal_error("Fatal error: ", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left);
        System.err.println(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left);
        System.out.println(msg.toString());
    } 
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		System.out.println(s.toString() + " " + s.value.toString());

	return s;
:}


terminal LBRACE, RBRACE, SEMI, LPAREN, RPAREN, LBRACKET, RBRACKET;
terminal COMMA, DBLCOLON;
terminal PLUS, EQUAL;
terminal PROGRAM, NSP;
terminal PRINT, RETURN, VOID, IF, ELSE, CONST;
terminal Integer NUM;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program;
nonterminal NspDecls, Namespace, NspName;
nonterminal GlobalDecls, GlobalDecl;
nonterminal ConstTypedDecl, ConstDecls, ConstDecl, Const;
nonterminal VarTypedDecls, VarTypedDecl, VarDecls, VarDecl, VarQuantity;
nonterminal MethodDecls, MethodDecl;
nonterminal FormPars, FormParams, FormParam;
nonterminal Statement;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, MethodSign;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

precedence left ELSE;

Program 	::= (Program) PROGRAM ProgName NspDecls GlobalDecls LBRACE MethodDecls RBRACE;
ProgName	::= (ProgName) IDENT:name;

NspDecls	::= NspDecls Namespace
			  | /* epsilon */;

Namespace	::= (Namespace) NSP NspName LBRACE GlobalDecls LBRACE MethodDecls RBRACE RBRACE;
NspName		::= (NspName) IDENT:name;

Type    ::= (Type) IDENT:name;

GlobalDecls	::= GlobalDecls GlobalDecl
			  | /* epsilon */;
GlobalDecl	::= (GlobalConstDecl) ConstTypedDecl
			  | (GlobalVarDecl) VarTypedDecl;

ConstTypedDecl	::= (ConstTypedDecl) CONST Type ConstDecls SEMI;
ConstDecls		::= ConstDecls COMMA ConstDecl
				  | ConstDecl;
ConstDecl		::= (ConstDecl) IDENT:name EQUAL Const;
Const			::= (IntConst) NUM:value
	   			  | (CharConst) CHAR:value
				  | (BoolConst) BOOL:value;

VarTypedDecls	::= VarTypedDecls VarTypedDecl
			  	  | /* epsilon */;
VarTypedDecl	::= (VarTypedDecl) Type VarDecls SEMI;
VarDecls		::= VarDecls COMMA VarDecl
				  | VarDecl;
VarDecl			::= (VarDecl) IDENT:name VarQuantity;
VarQuantity     ::= (ArrayVar) LBRACKET RBRACKET
				  | (SingularVar) /* epsilon */;

MethodDecls	::= MethodDecls MethodDecl
			  | /* epsilon */;
MethodDecl	::= (MethodDecl) MethodSign LPAREN FormPars RPAREN VarTypedDecls LBRACE Statement RBRACE;
MethodSign	::= (ValueMethodSign) Type IDENT:name
			  | (VoidMethodSign) VOID IDENT:name;

FormPars	::= FormParams
			  | /* epsilon */;
FormParams	::= FormParams COMMA FormParam
			  | FormParam;
FormParam	::= (FormParam) Type IDENT:name VarQuantity;

Statement ::= ;