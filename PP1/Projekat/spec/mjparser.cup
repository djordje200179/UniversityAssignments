package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
	private boolean errorDetected = false;
	
	public boolean hasError() {
		return errorDetected;
	}
     
    public void report_fatal_error(String message, Object info) throws Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error: ", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_fatal_error("Fatal error: ", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left);
        System.err.println(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left);
        System.out.println(msg.toString());
    } 
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		System.out.println(s + " " + s.value.toString());

	return s;
:}


terminal LBRACE, RBRACE, SEMI, LPAREN, RPAREN, LBRACKET, RBRACKET;
terminal COMMA, DBLCOLON;
terminal PLUS, MINUS, ASTERISK, SLASH, PERCENT, EQUAL;
terminal PROGRAM, NAMESPACE, PRINT, READ, RETURN, VOID, IF, ELSE, CONST, NEW, BREAK, CONTINUE;

terminal Integer NUM;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program;
nonterminal NspDecls, NspDecl, NspName;
nonterminal GlobalDecls, GlobalDecl;
nonterminal ConstTypedDecl, ConstDecls, ConstDecl;
nonterminal VarTypedDecls, VarTypedDecl, VarDecls, VarDecl;
nonterminal ElemAccess, VarQuantity;
nonterminal MethodDecls, MethodDecl;
nonterminal FormPars, FormParams, FormParam;
nonterminal Statement, StmtList;
nonterminal Addop, Mulop;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, MethodSign;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Const, Factor, Term, Expr, VarRef, Designator;
nonterminal ActPars, ActParams;

precedence left ELSE;

Program 	::= (Program) PROGRAM ProgName NspDecls GlobalDecls LBRACE MethodDecls RBRACE;
ProgName	::= (ProgName) IDENT:name;

NspDecls    ::= NspDecls NspDecl
			  | /* epsilon */;
NspDecl     ::= (NspDecl) NAMESPACE NspName LBRACE GlobalDecls LBRACE MethodDecls RBRACE RBRACE;
NspName     ::= (NspName) IDENT:name;

Type    ::= (Type) IDENT:name;

GlobalDecls	::= GlobalDecls GlobalDecl
			  | /* epsilon */;
GlobalDecl	::= (GlobalConstDecl) ConstTypedDecl
			  | (GlobalVarDecl) VarTypedDecl;

ConstTypedDecl	::= (ConstTypedDecl) CONST Type ConstDecls SEMI;
ConstDecls		::= ConstDecls COMMA ConstDecl
				  | ConstDecl;
ConstDecl		::= (ConstDecl) IDENT:name EQUAL Const;
Const			::= (IntConst) NUM:value
	   			  | (CharConst) CHAR:value
				  | (BoolConst) BOOL:value;

VarTypedDecls	::= VarTypedDecls VarTypedDecl
			  	  | /* epsilon */;
VarTypedDecl	::= (VarTypedDecl) Type VarDecls SEMI;
VarDecls		::= VarDecls COMMA VarDecl
				  | VarDecl;
VarDecl			::= (VarDecl) IDENT:name VarQuantity;
VarQuantity     ::= (ArrayVar) LBRACKET RBRACKET
				  | (SingularVar) /* epsilon */;

MethodDecls	::= MethodDecls MethodDecl
			  | /* epsilon */;
MethodDecl	::= (MethodDecl) MethodSign LPAREN FormPars RPAREN VarTypedDecls LBRACE StmtList RBRACE;
MethodSign	::= (ValueMethodSign) Type IDENT:name
			  | (VoidMethodSign) VOID IDENT:name;

FormPars	::= FormParams
			  | /* epsilon */;
FormParams	::= FormParams COMMA FormParam
			  | FormParam;
FormParam	::= (FormParam) Type IDENT:name VarQuantity;

StmtList    ::= StmtList Statement
			  | /* epsilon */;
Statement   ::= (ValueReturnStmt) RETURN Expr SEMI
			  | (VoidReturnStmt) RETURN SEMI
			  | (BreakStmt) BREAK SEMI
			  | (ContinueStmt) CONTINUE SEMI
			  | (ReadStmt) READ LPAREN Designator RPAREN SEMI
			  | (PrintWidthStmt) PRINT LPAREN Expr COMMA NUM:width RPAREN SEMI
			  | (PrintStmt) PRINT LPAREN Expr RPAREN SEMI;

Addop ::= PLUS | MINUS;
Mulop ::= ASTERISK | SLASH | PERCENT;

ActPars     ::= ActParams
		      | /* epsilon */;
ActParams   ::= ActParams COMMA Expr
			  | Expr;

Factor ::= (ConstFactor) Const
		 | (GroupedFactor) LPAREN Expr RPAREN
		 | (NewArrayFactor) NEW Type LBRACKET Expr RBRACKET
		 | (FuncCallFactor) Designator LPAREN ActPars RPAREN
		 | (DesignatorFactor) Designator;

Term ::= (FactorTermList) Term Mulop Factor
	   | (FactorTerm) Factor;

Expr ::= (ExprTermList) Expr Addop Term
	   | (ExprTerm) Term
	   | (ExprNegTerm) MINUS Term;

VarRef      ::= (BlankVarRef) IDENT:varName
			  | (NspVarRef) IDENT:nspName DBLCOLON IDENT:varName;
Designator  ::= (Designator) VarRef ElemAccess;
ElemAccess  ::= (ArrayElemAccess) LBRACKET Expr RBRACKET
			  | (SingularAccess) /* epsilon */;