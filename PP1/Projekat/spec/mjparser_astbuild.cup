package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	private boolean errorDetected = false;
	
	public boolean hasError() {
		return errorDetected;
	}
     
    public void report_fatal_error(String message, Object info) throws Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error: ", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_fatal_error("Fatal error: ", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left);
        System.err.println(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" at line ").append(((Symbol)info).left);
        System.out.println(msg.toString());
    } 
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		System.out.println(s.toString() + " " + s.value.toString());

	return s;
:}


terminal LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, DBLCOLON;
terminal PLUS, EQUAL;
terminal PROGRAM, NSP;
terminal PRINT, RETURN, VOID, IF, ELSE, CONST;
terminal Integer NUM;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program Program;
nonterminal ProgName ProgName;
nonterminal NspDecls NspDecls;
nonterminal Namespace Namespace;
nonterminal NspName NspName;
nonterminal GlobalDecls GlobalDecls;
nonterminal GlobalDecl GlobalDecl;
nonterminal Type Type;
nonterminal ConstTypedDecl ConstTypedDecl;
nonterminal ConstDecls ConstDecls;
nonterminal ConstDecl ConstDecl;
nonterminal Const Const;
nonterminal VarTypedDecls VarTypedDecls;
nonterminal VarTypedDecl VarTypedDecl;
nonterminal VarDecls VarDecls;
nonterminal VarDecl VarDecl;
nonterminal MethodDecls MethodDecls;
nonterminal MethodDecl MethodDecl;
nonterminal MethodSign MethodSign;
nonterminal FormPars FormPars;
nonterminal FormParams FormParams;
nonterminal FormParam FormParam;
nonterminal Statement Statement;

precedence left ELSE;

Program 	::= (Program) PROGRAM ProgName:P1 NspDecls:N2 GlobalDecls:G3 LBRACE MethodDecls:M4 RBRACE {: RESULT=new Program(P1, N2, G3, M4); RESULT.setLine(P1left); :};
ProgName	::= (ProgName) IDENT:name {: RESULT=new ProgName(name); RESULT.setLine(nameleft); :};

NspDecls	::= NspDecls:N1 Namespace:N2 {: RESULT=new NspDeclsDerived1(N1, N2); RESULT.setLine(N1left); :}
			  | {: RESULT=new NspDeclsDerived2(); :} /* epsilon */;
			  
Namespace	::= (Namespace) NSP NspName:N1 LBRACE GlobalDecls:G2 LBRACE MethodDecls:M3 RBRACE RBRACE {: RESULT=new Namespace(N1, G2, M3); RESULT.setLine(N1left); :};
NspName		::= (NspName) IDENT:name {: RESULT=new NspName(name); RESULT.setLine(nameleft); :};

GlobalDecls	::= GlobalDecls:G1 GlobalDecl:G2 {: RESULT=new GlobalDeclsDerived1(G1, G2); RESULT.setLine(G1left); :}
			  | {: RESULT=new GlobalDeclsDerived2(); :} /* epsilon */;
GlobalDecl	::= (GlobalConstDecl) ConstTypedDecl:C1 {: RESULT=new GlobalConstDecl(C1); RESULT.setLine(C1left); :}
			  | (GlobalVarDecl) VarTypedDecl:V1 {: RESULT=new GlobalVarDecl(V1); RESULT.setLine(V1left); :};
				  	  
ConstTypedDecl	::= (ConstTypedDecl) CONST IDENT:type ConstDecls:C1 SEMI {: RESULT=new ConstTypedDecl(type, C1); RESULT.setLine(typeleft); :};
ConstDecls		::= ConstDecls:C1 COMMA ConstDecl:C2 {: RESULT=new ConstDeclsDerived1(C1, C2); RESULT.setLine(C1left); :}
				  | ConstDecl:C1 {: RESULT=new ConstDeclsDerived2(C1); RESULT.setLine(C1left); :};
ConstDecl		::= (ConstDecl) IDENT:name EQUAL Const:C1 {: RESULT=new ConstDecl(name, C1); RESULT.setLine(nameleft); :};
Const			::= (IntConst) NUM:value {: RESULT=new IntConst(value); RESULT.setLine(valueleft); :}
	   			  | (CharConst) CHAR:value {: RESULT=new CharConst(value); RESULT.setLine(valueleft); :}
				  | (BoolConst) BOOL:value {: RESULT=new BoolConst(value); RESULT.setLine(valueleft); :};

VarTypedDecls	::= VarTypedDecls:V1 VarTypedDecl:V2 {: RESULT=new VarTypedDeclsDerived1(V1, V2); RESULT.setLine(V1left); :}
			  	  | {: RESULT=new VarTypedDeclsDerived2(); :} /* epsilon */;
VarTypedDecl	::= (VarTypedDecl) IDENT:type VarDecls:V1 SEMI {: RESULT=new VarTypedDecl(type, V1); RESULT.setLine(typeleft); :};
VarDecls		::= VarDecls:V1 COMMA VarDecl:V2 {: RESULT=new VarDeclsDerived1(V1, V2); RESULT.setLine(V1left); :}
				  | VarDecl:V1 {: RESULT=new VarDeclsDerived2(V1); RESULT.setLine(V1left); :};
VarDecl			::= (VarDecl) IDENT:name {: RESULT=new VarDecl(name); RESULT.setLine(nameleft); :};
			 
MethodDecls	::= MethodDecls:M1 MethodDecl:M2 {: RESULT=new MethodDeclsDerived1(M1, M2); RESULT.setLine(M1left); :}
			  | {: RESULT=new MethodDeclsDerived2(); :} /* epsilon */;
MethodDecl	::= (MethodDecl) MethodSign:M1 LPAREN FormPars:F2 RPAREN VarTypedDecls:V3 LBRACE Statement:S4 RBRACE {: RESULT=new MethodDecl(M1, F2, V3, S4); RESULT.setLine(M1left); :};
MethodSign	::= (ValueMethodSign) IDENT:type IDENT:name {: RESULT=new ValueMethodSign(type, name); RESULT.setLine(typeleft); :}
			  | (VoidMethodSign) VOID IDENT:name {: RESULT=new VoidMethodSign(name); RESULT.setLine(nameleft); :};

FormPars	::= FormParams:F1 {: RESULT=new FormParsDerived1(F1); RESULT.setLine(F1left); :}
			  | {: RESULT=new FormParsDerived2(); :} /* epsilon */;
FormParams	::= FormParams:F1 COMMA FormParam:F2 {: RESULT=new FormParamsDerived1(F1, F2); RESULT.setLine(F1left); :}
			  | FormParam:F1 {: RESULT=new FormParamsDerived2(F1); RESULT.setLine(F1left); :};
FormParam	::= (FormParam) IDENT:type IDENT:name {: RESULT=new FormParam(type, name); RESULT.setLine(typeleft); :};

Statement ::= {: RESULT=new StatementDerived1(); :} ;